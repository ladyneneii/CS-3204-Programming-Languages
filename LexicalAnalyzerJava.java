import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

class LexicalAnalyzerJava {
    // Constants
    public static final int MAX_LEXEME = 100;
    public static final int EOF = -1;
    // Character classes
    public static final int LETTER = 0;
    public static final int DIGIT = 1;
    public static final int UNKNOWN = 99;
    // Token codes
    public static final int INT_LIT = 10;
    public static final int IDENT = 11;
    public static final int ASSIGN_OP = 20;
    public static final int ADD_OP = 21;
    public static final int SUB_OP = 22;
    public static final int MULT_OP = 23;
    public static final int DIV_OP = 24;
    public static final int LEFT_PAREN = 25;
    public static final int RIGHT_PAREN = 26;
    // Global variables
    private static String file_content;
    private static int idx = 0;
    private static int charClass;
    private static String lexeme = "";
    private static char nextChar;
    private static int nextToken = -999;

    public static void getChar() {
        if (idx < file_content.length()) {
            nextChar = file_content.charAt(idx);
            if (Character.isLetter(nextChar)) 
                charClass = LETTER;
            else if (Character.isDigit(nextChar)) 
                charClass = DIGIT;
            else 
                charClass = UNKNOWN;
            // charClass = Character.isLetter(nextChar) ? LETTER :
            //             Character.isDigit(nextChar) ? DIGIT : UNKNOWN;
            idx++;
        } else {
            nextChar = '-';
            charClass = EOF;
        }
    }

    public static void addChar() {
        if (lexeme.length() <= MAX_LEXEME - 2) // max 99
            lexeme += nextChar;
        else
            System.out.println("Error - lexeme is too long");
    }

    public static int lookup(char ch) {
        switch (ch) {
            case '(': return LEFT_PAREN;
            case ')': return RIGHT_PAREN;
            case '+': return ADD_OP;
            case '-': return SUB_OP;
            case '*': return MULT_OP;
            case '/': return DIV_OP;
            default: return EOF;
        }
    }

    public static void lex() {
        lexeme = "";

        while (Character.isWhitespace(nextChar)) 
            getChar();

        if (charClass == LETTER) {
            // Parse identifiers 
            while (charClass == LETTER || charClass == DIGIT) {
                addChar();
                getChar();
                nextToken = IDENT;
            }
        } else if (charClass == DIGIT) { 
            /* Parse integer literals */
            while (charClass == DIGIT) {
                addChar();
                getChar();
            }
            nextToken = INT_LIT;
        } else if (charClass == UNKNOWN) {
            /* Parentheses and operators */
            nextToken = lookup(nextChar);
            addChar();
            getChar();
        } else {
            /* EOF */
            nextToken = EOF;
            lexeme = "EOF";
        }
        System.out.printf("Next token is: %d, Next lexeme is %s%n", nextToken, lexeme);
    }

    public static void expr() {
        System.out.println("Enter <expr>");
        /* Parse the first term */
        term();
        /* As long as the next token is + or -, get
        the next token and parse the next term */
        while  (nextToken == ADD_OP || nextToken == SUB_OP) {
            lex();
            term();
        }
        System.out.println("Exit <expr>");
    }  /* End of function expr */

    /* term parses strings in the language generated by the rule:
    <term> -> <factor> {(* | /) <factor>) 
    */
    public static void term() {
        System.out.println("Enter <term>");
        /* Parse the first factor */
        factor();
        /* As long as the next token is * or /, get the
        next token and parse the next factor */
        while  (nextToken == MULT_OP || nextToken == DIV_OP) {
            lex();
            factor();
        }
        System.out.println("Exit <term>");
    }  /* End of function term */

    /* factor parses strings in the language generated by the rule:
    <factor> -> id | int_constant | ( <expr )
    */
    public static void factor() {
        System.out.println("Enter <factor>");
        /* Determine which RHS */
        if (nextToken == IDENT || nextToken == INT_LIT) {
        /* Get the next token */
            lex();
        /* If the RHS is ( <expr> ), call lex to pass over the 
        left parenthesis, call expr, and check for the right
        parenthesis */
        } else  {
            if  (nextToken == LEFT_PAREN) {
                lex();
                expr();
                if (nextToken == RIGHT_PAREN)
                    lex();
                else
                    error();
            }  /* End of if (nextToken == ... */
            /* It was not an id, an integer literal, or a left
            parenthesis */
            else error();
        } /* End of else */
        System.out.println("Exit <factor>");
    } /* End of function factor */

    public static void error() {
        System.out.println("ERROR!!!");
    }

    public static void main(String[] args) {
        try {
            Path path = Paths.get("front.in");
            file_content = Files.readString(path);
            getChar();
            while (nextToken != EOF){
                lex();
                expr();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

